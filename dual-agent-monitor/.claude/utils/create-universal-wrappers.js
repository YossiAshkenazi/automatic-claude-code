#!/usr/bin/env node

/**
 * Script to generate universal wrapper scripts for all hook types
 */

const fs = require('fs');
const path = require('path');

// List of all hook types
const HOOK_TYPES = [
  'user-prompt-submit-hook',
  'pre-tool-use-hook',
  'post-tool-use-hook',
  'notification-hook',
  'pre-compact-hook',
  'stop-hook',
  'subagent-stop-hook'
];

/**
 * Generate the universal wrapper script template
 * @param {string} hookName - Name of the hook
 * @returns {string} - Script content
 */
function generateWrapperScript(hookName) {
  return `#!/usr/bin/env node

/**
 * Universal Hook Wrapper for ${hookName}
 * 
 * This script automatically detects the current platform (Windows/WSL/Linux)
 * and delegates execution to the appropriate platform-specific implementation.
 * 
 * Generated by: utils/create-universal-wrappers.js
 */

const path = require('path');
const UniversalHookWrapper = require(path.join(__dirname, '..', 'utils', 'universal-hook-wrapper.js'));

async function main() {
  // Get command line arguments (excluding node and script path)
  const args = process.argv.slice(2);
  
  // Create wrapper instance
  const wrapper = new UniversalHookWrapper({
    debug: process.env.DEBUG === 'true',
    hookDir: path.join(__dirname)
  });

  try {
    // Execute the hook
    const result = await wrapper.run('${hookName}', args);
    
    // Output results
    if (result.stdout) {
      process.stdout.write(result.stdout);
    }
    
    if (result.stderr) {
      process.stderr.write(result.stderr);
    }
    
    // Exit with the same code as the underlying script
    process.exit(result.exitCode);
    
  } catch (error) {
    console.error(\`Universal wrapper error: \${error.message}\`);
    process.exit(1);
  }
}

// Run the main function
if (require.main === module) {
  main().catch(error => {
    console.error(\`Fatal error: \${error.message}\`);
    process.exit(1);
  });
}

module.exports = main;
`;
}

/**
 * Create universal wrapper scripts for all hook types
 */
function createUniversalWrappers() {
  const outputDir = path.join(__dirname, '..', 'universal-hooks');
  
  // Create output directory if it doesn't exist
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  console.log('Creating universal hook wrappers...');
  
  for (const hookName of HOOK_TYPES) {
    const scriptContent = generateWrapperScript(hookName);
    const outputPath = path.join(outputDir, `${hookName}.js`);
    
    fs.writeFileSync(outputPath, scriptContent, 'utf8');
    
    // Make the script executable on Unix-like systems
    try {
      fs.chmodSync(outputPath, 0o755);
    } catch (error) {
      // chmod might not work on Windows, ignore the error
    }
    
    console.log(`Created: ${outputPath}`);
  }
  
  console.log(`\nSuccessfully created ${HOOK_TYPES.length} universal hook wrappers in: ${outputDir}`);
  console.log('\nTo use these wrappers, update your .claude/settings.json to point to these JavaScript files.');
}

// Run if called directly
if (require.main === module) {
  createUniversalWrappers();
}

module.exports = { createUniversalWrappers, generateWrapperScript, HOOK_TYPES };