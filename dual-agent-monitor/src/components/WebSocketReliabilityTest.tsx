import React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Progress } from '@/components/ui/progress';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Separator } from '@/components/ui/separator';\nimport { \n  PlayCircle, \n  PauseCircle, \n  StopCircle, \n  RefreshCw,\n  Wifi,\n  WifiOff,\n  Activity,\n  CheckCircle,\n  XCircle,\n  AlertTriangle,\n  Clock,\n  Zap\n} from 'lucide-react';\nimport { useWebSocket } from '../hooks/useWebSocket';\nimport ConnectionHealthDashboard from './ConnectionHealthDashboard';\n\ninterface TestScenario {\n  id: string;\n  name: string;\n  description: string;\n  duration: number; // in seconds\n  test: (ws: any) => Promise<void>;\n}\n\nconst WebSocketReliabilityTest: React.FC = () => {\n  const [isTestRunning, setIsTestRunning] = useState(false);\n  const [currentTest, setCurrentTest] = useState<string | null>(null);\n  const [testResults, setTestResults] = useState<Record<string, any>>({});\n  const [testProgress, setTestProgress] = useState(0);\n  const [logs, setLogs] = useState<string[]>([]);\n  const [connectionStats, setConnectionStats] = useState({\n    totalMessages: 0,\n    successfulMessages: 0,\n    failedMessages: 0,\n    averageLatency: 0,\n    reconnectionCount: 0\n  });\n\n  // WebSocket configuration for testing\n  const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host.replace(':6011', ':4001')}`;\n  \n  const {\n    isConnected,\n    isConnecting,\n    isReconnecting,\n    connectionStatus,\n    connectionHealth,\n    connectionReliability,\n    qualityMetrics,\n    isUsingFallback,\n    sendMessage,\n    reconnect,\n    disconnect,\n    connectionMonitor\n  } = useWebSocket(wsUrl, {\n    maxReconnectAttempts: 10,\n    reconnectInterval: 1000,\n    exponentialBackoff: true,\n    maxBackoffDelay: 30000,\n    heartbeatInterval: 5000, // More frequent for testing\n    heartbeatTimeout: 3000,\n    enableFallback: true,\n    fallbackPollInterval: 3000,\n    onMessage: (message) => {\n      try {\n        const parsed = JSON.parse(message);\n        if (parsed.type !== 'ping' && parsed.type !== 'pong') {\n          addLog(`📨 Received: ${parsed.type}`);\n          setConnectionStats(prev => ({\n            ...prev,\n            totalMessages: prev.totalMessages + 1,\n            successfulMessages: prev.successfulMessages + 1\n          }));\n        }\n      } catch (error) {\n        addLog(`❌ Failed to parse message: ${error}`);\n      }\n    },\n    onReconnectAttempt: (attempt) => {\n      addLog(`🔄 Reconnection attempt ${attempt}`);\n      setConnectionStats(prev => ({\n        ...prev,\n        reconnectionCount: prev.reconnectionCount + 1\n      }));\n    },\n    onFallbackActivated: () => {\n      addLog('🔄 HTTP fallback activated');\n    },\n    onHealthUpdate: (health) => {\n      setConnectionStats(prev => ({\n        ...prev,\n        averageLatency: health.averageLatency\n      }));\n    }\n  });\n\n  const addLog = (message: string) => {\n    const timestamp = new Date().toLocaleTimeString();\n    setLogs(prev => [`[${timestamp}] ${message}`, ...prev.slice(0, 49)]); // Keep last 50 logs\n  };\n\n  const testScenarios: TestScenario[] = [\n    {\n      id: 'basic_connectivity',\n      name: 'Basic Connectivity',\n      description: 'Test basic WebSocket connection and message sending',\n      duration: 10,\n      test: async (ws) => {\n        for (let i = 0; i < 5; i++) {\n          const success = sendMessage({ type: 'test_message', data: `Test ${i + 1}` });\n          addLog(success ? `✅ Message ${i + 1} sent` : `❌ Message ${i + 1} failed`);\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      }\n    },\n    {\n      id: 'connection_stability',\n      name: 'Connection Stability',\n      description: 'Monitor connection stability over time',\n      duration: 30,\n      test: async (ws) => {\n        const startTime = Date.now();\n        const interval = setInterval(() => {\n          const elapsed = (Date.now() - startTime) / 1000;\n          if (elapsed >= 30) {\n            clearInterval(interval);\n            return;\n          }\n          \n          if (isConnected) {\n            sendMessage({ type: 'stability_ping', timestamp: Date.now() });\n          }\n        }, 2000);\n        \n        await new Promise(resolve => setTimeout(resolve, 30000));\n      }\n    },\n    {\n      id: 'reconnection_resilience',\n      name: 'Reconnection Resilience',\n      description: 'Test reconnection behavior by forcing disconnections',\n      duration: 20,\n      test: async (ws) => {\n        addLog('🔌 Testing reconnection resilience...');\n        \n        // Force disconnect\n        addLog('🔌 Forcing disconnect...');\n        disconnect();\n        await new Promise(resolve => setTimeout(resolve, 3000));\n        \n        // Reconnect\n        addLog('🔌 Attempting reconnect...');\n        reconnect();\n        await new Promise(resolve => setTimeout(resolve, 5000));\n        \n        // Test message sending after reconnect\n        if (isConnected) {\n          sendMessage({ type: 'post_reconnect_test', data: 'Testing after reconnect' });\n          addLog('✅ Post-reconnect message sent');\n        } else {\n          addLog('❌ Still disconnected after reconnect attempt');\n        }\n      }\n    },\n    {\n      id: 'high_frequency',\n      name: 'High Frequency Messaging',\n      description: 'Test with rapid message sending to check reliability',\n      duration: 15,\n      test: async (ws) => {\n        const messageCount = 100;\n        let successCount = 0;\n        \n        addLog(`📤 Sending ${messageCount} rapid messages...`);\n        \n        for (let i = 0; i < messageCount; i++) {\n          const success = sendMessage({ \n            type: 'high_frequency_test', \n            index: i,\n            timestamp: Date.now()\n          });\n          \n          if (success) successCount++;\n          \n          // Small delay to prevent overwhelming\n          if (i % 10 === 0) {\n            await new Promise(resolve => setTimeout(resolve, 100));\n          }\n        }\n        \n        addLog(`📊 High frequency test: ${successCount}/${messageCount} messages sent`);\n        setTestResults(prev => ({\n          ...prev,\n          high_frequency: {\n            total: messageCount,\n            successful: successCount,\n            success_rate: (successCount / messageCount) * 100\n          }\n        }));\n      }\n    },\n    {\n      id: 'latency_measurement',\n      name: 'Latency Measurement',\n      description: 'Measure round-trip latency and jitter',\n      duration: 20,\n      test: async (ws) => {\n        const measurements: number[] = [];\n        \n        for (let i = 0; i < 10; i++) {\n          const startTime = Date.now();\n          sendMessage({ \n            type: 'latency_test', \n            timestamp: startTime,\n            index: i\n          });\n          \n          // Wait for response (simplified - in real implementation, \n          // we'd listen for specific responses)\n          await new Promise(resolve => setTimeout(resolve, 1000));\n          \n          if (qualityMetrics?.latency) {\n            measurements.push(qualityMetrics.latency);\n          }\n          \n          addLog(`⏱️ Latency measurement ${i + 1}: ${qualityMetrics?.latency || 0}ms`);\n        }\n        \n        if (measurements.length > 0) {\n          const avgLatency = measurements.reduce((a, b) => a + b, 0) / measurements.length;\n          const maxLatency = Math.max(...measurements);\n          const minLatency = Math.min(...measurements);\n          \n          setTestResults(prev => ({\n            ...prev,\n            latency: {\n              average: avgLatency,\n              min: minLatency,\n              max: maxLatency,\n              measurements\n            }\n          }));\n          \n          addLog(`📊 Latency results - Avg: ${avgLatency.toFixed(1)}ms, Min: ${minLatency}ms, Max: ${maxLatency}ms`);\n        }\n      }\n    }\n  ];\n\n  const runTest = async (scenario: TestScenario) => {\n    if (isTestRunning) return;\n    \n    setIsTestRunning(true);\n    setCurrentTest(scenario.id);\n    setTestProgress(0);\n    addLog(`🚀 Starting test: ${scenario.name}`);\n    \n    const progressInterval = setInterval(() => {\n      setTestProgress(prev => {\n        const newProgress = prev + (100 / scenario.duration);\n        return newProgress >= 100 ? 100 : newProgress;\n      });\n    }, 1000);\n    \n    try {\n      await scenario.test({ sendMessage, isConnected });\n      addLog(`✅ Test completed: ${scenario.name}`);\n    } catch (error) {\n      addLog(`❌ Test failed: ${scenario.name} - ${error}`);\n    } finally {\n      clearInterval(progressInterval);\n      setTestProgress(100);\n      setIsTestRunning(false);\n      setCurrentTest(null);\n    }\n  };\n\n  const runAllTests = async () => {\n    for (const scenario of testScenarios) {\n      await runTest(scenario);\n      // Wait between tests\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n  };\n\n  const clearLogs = () => {\n    setLogs([]);\n    setTestResults({});\n    setConnectionStats({\n      totalMessages: 0,\n      successfulMessages: 0,\n      failedMessages: 0,\n      averageLatency: 0,\n      reconnectionCount: 0\n    });\n  };\n\n  const getConnectionStatusBadge = () => {\n    let color = 'bg-gray-500';\n    let icon = <WifiOff className=\"h-3 w-3\" />;\n    \n    if (isReconnecting) {\n      color = 'bg-yellow-500';\n      icon = <RefreshCw className=\"h-3 w-3 animate-spin\" />;\n    } else if (isConnected) {\n      color = 'bg-green-500';\n      icon = <Wifi className=\"h-3 w-3\" />;\n    } else if (isUsingFallback) {\n      color = 'bg-orange-500';\n      icon = <Zap className=\"h-3 w-3\" />;\n    }\n    \n    return (\n      <Badge className={`${color} text-white flex items-center space-x-1`}>\n        {icon}\n        <span className=\"capitalize\">{connectionStatus}</span>\n      </Badge>\n    );\n  };\n\n  return (\n    <div className=\"space-y-6 p-6 max-w-7xl mx-auto\">\n      <div className=\"flex items-center justify-between\">\n        <h1 className=\"text-2xl font-bold\">WebSocket Reliability Testing</h1>\n        {getConnectionStatusBadge()}\n      </div>\n\n      {/* Connection Health Dashboard */}\n      <ConnectionHealthDashboard\n        isConnected={isConnected}\n        isReconnecting={isReconnecting}\n        connectionStatus={connectionStatus}\n        connectionHealth={connectionHealth}\n        connectionReliability={connectionReliability}\n        isUsingFallback={isUsingFallback}\n        onReconnect={reconnect}\n      />\n\n      {/* Test Scenarios */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center space-x-2\">\n            <Activity className=\"h-5 w-5\" />\n            <span>Reliability Test Scenarios</span>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-4\">\n            <div className=\"flex space-x-2\">\n              <Button \n                onClick={runAllTests} \n                disabled={isTestRunning || !isConnected}\n                className=\"flex items-center space-x-2\"\n              >\n                <PlayCircle className=\"h-4 w-4\" />\n                <span>Run All Tests</span>\n              </Button>\n              <Button variant=\"outline\" onClick={clearLogs}>\n                Clear Logs\n              </Button>\n            </div>\n            \n            {currentTest && (\n              <div className=\"space-y-2\">\n                <div className=\"flex justify-between text-sm\">\n                  <span>Running: {testScenarios.find(t => t.id === currentTest)?.name}</span>\n                  <span>{Math.round(testProgress)}%</span>\n                </div>\n                <Progress value={testProgress} className=\"h-2\" />\n              </div>\n            )}\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n              {testScenarios.map((scenario) => (\n                <Card key={scenario.id} className=\"cursor-pointer hover:shadow-md transition-shadow\">\n                  <CardHeader className=\"pb-2\">\n                    <CardTitle className=\"text-sm\">{scenario.name}</CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <p className=\"text-xs text-gray-600 mb-3\">{scenario.description}</p>\n                    <div className=\"flex justify-between items-center\">\n                      <span className=\"text-xs text-gray-500\">{scenario.duration}s</span>\n                      <Button\n                        size=\"sm\"\n                        onClick={() => runTest(scenario)}\n                        disabled={isTestRunning || !isConnected}\n                        variant={currentTest === scenario.id ? \"default\" : \"outline\"}\n                      >\n                        {currentTest === scenario.id ? (\n                          <PauseCircle className=\"h-3 w-3\" />\n                        ) : (\n                          <PlayCircle className=\"h-3 w-3\" />\n                        )}\n                      </Button>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Connection Statistics */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center space-x-2\">\n            <CheckCircle className=\"h-5 w-5\" />\n            <span>Connection Statistics</span>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-blue-600\">{connectionStats.totalMessages}</div>\n              <div className=\"text-sm text-gray-600\">Total Messages</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-green-600\">{connectionReliability.toFixed(1)}%</div>\n              <div className=\"text-sm text-gray-600\">Reliability</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-yellow-600\">{qualityMetrics?.latency?.toFixed(1) || 0}ms</div>\n              <div className=\"text-sm text-gray-600\">Avg Latency</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-orange-600\">{connectionStats.reconnectionCount}</div>\n              <div className=\"text-sm text-gray-600\">Reconnections</div>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Test Results */}\n      {Object.keys(testResults).length > 0 && (\n        <Card>\n          <CardHeader>\n            <CardTitle>Test Results</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-4\">\n              {Object.entries(testResults).map(([testId, results]: [string, any]) => (\n                <div key={testId}>\n                  <h4 className=\"font-medium capitalize\">{testId.replace('_', ' ')}</h4>\n                  <pre className=\"bg-gray-100 p-2 rounded text-sm overflow-auto\">\n                    {JSON.stringify(results, null, 2)}\n                  </pre>\n                </div>\n              ))}\n            </div>\n          </CardContent>\n        </Card>\n      )}\n\n      {/* Activity Log */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center space-x-2\">\n            <Clock className=\"h-5 w-5\" />\n            <span>Activity Log</span>\n            <span className=\"text-sm text-gray-500\">({logs.length} entries)</span>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"max-h-64 overflow-y-auto bg-gray-50 p-3 rounded font-mono text-sm\">\n            {logs.length === 0 ? (\n              <div className=\"text-gray-500 text-center\">No activity yet...</div>\n            ) : (\n              logs.map((log, index) => (\n                <div key={index} className=\"mb-1\">\n                  {log}\n                </div>\n              ))\n            )}\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n\nexport default WebSocketReliabilityTest;"